package com.ordersystem.query.chaos;

import com.ordersystem.query.dto.PaymentRequest;
import com.ordersystem.query.dto.PaymentResult;
import com.ordersystem.query.dto.StockLevel;
import com.ordersystem.query.service.ResilientQueryService;
import com.ordersystem.query.service.ExternalPaymentService;
import com.ordersystem.query.service.ExternalInventoryService;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit.jupiter.SpringJUnitExtension;

import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.List;
import java.util.ArrayList;

import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

/**
 * Chaos Engineering tests for circuit breaker resilience
 * Validates system behavior under various failure scenarios
 */
@ExtendWith(SpringJUnitExtension.class)
@SpringBootTest
class CircuitBreakerChaosTest {

    @Autowired
    private ResilientQueryService resilientQueryService;

    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;

    @MockBean
    private ExternalPaymentService externalPaymentService;

    @MockBean
    private ExternalInventoryService externalInventoryService;

    private CircuitBreaker paymentCircuitBreaker;
    private CircuitBreaker inventoryCircuitBreaker;

    @BeforeEach
    void setUp() {
        paymentCircuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-service");
        inventoryCircuitBreaker = circuitBreakerRegistry.circuitBreaker("inventory-service");
        
        // Reset circuit breakers
        paymentCircuitBreaker.reset();
        inventoryCircuitBreaker.reset();
    }

    @Test
    void shouldMaintainAvailabilityDuringPaymentServiceOutage() throws Exception {
        // Chaos Scenario: Payment service completely down
        when(externalPaymentService.processPayment(any()))
            .thenThrow(new ConnectException("Payment service unreachable"));

        // Execute multiple payment requests
        List<CompletableFuture<PaymentResult>> futures = new ArrayList<>();
        for (int i = 0; i < 20; i++) {
            PaymentRequest request = new PaymentRequest("order-" + i, 100.0, "USD");
            futures.add(resilientQueryService.processPayment(request));
        }

        // Wait for all requests to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get(10, TimeUnit.SECONDS);

        // Verify circuit breaker opened
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
        });

        // Verify fallback strategies were used
        long queuedPayments = futures.stream()
            .mapToLong(future -> {
                try {
                    PaymentResult result = future.get();
                    return "QUEUED".equals(result.getStatus()) || 
                           "PENDING_APPROVAL".equals(result.getStatus()) ? 1 : 0;
                } catch (Exception e) {
                    return 0;
                }
            })
            .sum();

        assertThat(queuedPayments).isGreaterThan(0);
        assertThat(queuedPayments).isEqualTo(20); // All should use fallback
    }

    @Test
    void shouldRecoverAutomaticallyWhenServiceComesBack() throws Exception {
        // Chaos Scenario: Service fails then recovers
        
        // Phase 1: Service fails
        when(externalPaymentService.processPayment(any()))
            .thenThrow(new SocketTimeoutException("Timeout"));

        // Trigger circuit breaker opening
        for (int i = 0; i < 15; i++) {
            try {
                PaymentRequest request = new PaymentRequest("fail-" + i, 100.0, "USD");
                resilientQueryService.processPayment(request).get(1, TimeUnit.SECONDS);
            } catch (Exception ignored) {
                // Expected during chaos
            }
        }

        // Verify circuit opened
        await().atMost(3, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
        });

        // Phase 2: Service recovers
        when(externalPaymentService.processPayment(any()))
            .thenReturn(PaymentResult.success("Payment processed", "txn-123"));

        // Wait for circuit breaker to transition to half-open
        await().atMost(15, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.HALF_OPEN);
        });

        // Execute successful requests to close circuit
        for (int i = 0; i < 5; i++) {
            PaymentRequest request = new PaymentRequest("recover-" + i, 100.0, "USD");
            PaymentResult result = resilientQueryService.processPayment(request).get(5, TimeUnit.SECONDS);
            assertThat(result.getStatus()).isEqualTo("SUCCESS");
        }

        // Verify circuit closed
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
        });
    }

    @Test
    void shouldIsolateFailuresBetweenServices() throws Exception {
        // Chaos Scenario: Only inventory service fails, payment should remain healthy
        
        when(externalInventoryService.checkStockLevel(anyString()))
            .thenThrow(new ConnectException("Inventory service down"));
        when(externalPaymentService.processPayment(any()))
            .thenReturn(PaymentResult.success("Payment OK", "txn-456"));

        // Trigger inventory failures
        List<CompletableFuture<StockLevel>> inventoryFutures = new ArrayList<>();
        for (int i = 0; i < 20; i++) {
            inventoryFutures.add(resilientQueryService.checkStockLevel("product-" + i));
        }

        // Execute payment requests (should succeed)
        List<CompletableFuture<PaymentResult>> paymentFutures = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            PaymentRequest request = new PaymentRequest("order-" + i, 100.0, "USD");
            paymentFutures.add(resilientQueryService.processPayment(request));
        }

        // Wait for all operations
        CompletableFuture.allOf(inventoryFutures.toArray(new CompletableFuture[0])).get(10, TimeUnit.SECONDS);
        CompletableFuture.allOf(paymentFutures.toArray(new CompletableFuture[0])).get(10, TimeUnit.SECONDS);

        // Verify isolation: inventory circuit open, payment circuit closed
        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(inventoryCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
        });

        // Verify payment requests succeeded
        long successfulPayments = paymentFutures.stream()
            .mapToLong(future -> {
                try {
                    PaymentResult result = future.get();
                    return "SUCCESS".equals(result.getStatus()) ? 1 : 0;
                } catch (Exception e) {
                    return 0;
                }
            })
            .sum();

        assertThat(successfulPayments).isEqualTo(10);
    }

    @Test
    void shouldHandleIntermittentFailures() throws Exception {
        // Chaos Scenario: Service has intermittent failures (50% failure rate)
        
        when(externalPaymentService.processPayment(any()))
            .thenThrow(new SocketTimeoutException("Intermittent timeout"))
            .thenReturn(PaymentResult.success("Success", "txn-1"))
            .thenThrow(new SocketTimeoutException("Intermittent timeout"))
            .thenReturn(PaymentResult.success("Success", "txn-2"))
            .thenThrow(new SocketTimeoutException("Intermittent timeout"))
            .thenReturn(PaymentResult.success("Success", "txn-3"));

        // Execute requests
        List<CompletableFuture<PaymentResult>> futures = new ArrayList<>();
        for (int i = 0; i < 6; i++) {
            PaymentRequest request = new PaymentRequest("intermittent-" + i, 100.0, "USD");
            futures.add(resilientQueryService.processPayment(request));
        }

        // Wait and collect results
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get(10, TimeUnit.SECONDS);

        // Circuit breaker should remain closed with 50% failure rate (below 30% threshold for payment)
        // But should track the failures
        assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
        assertThat(paymentCircuitBreaker.getMetrics().getFailureRate()).isGreaterThan(0);
    }

    @Test
    void shouldHandleSlowResponsesWithoutFailure() throws Exception {
        // Chaos Scenario: Service becomes very slow
        
        when(externalPaymentService.processPayment(any()))
            .then(invocation -> {
                // Simulate slow response (2 seconds, below 3s threshold)
                Thread.sleep(2000);
                return PaymentResult.success("Slow but successful", "txn-slow");
            });

        // Execute requests
        List<CompletableFuture<PaymentResult>> futures = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            PaymentRequest request = new PaymentRequest("slow-" + i, 100.0, "USD");
            futures.add(resilientQueryService.processPayment(request));
        }

        // Wait for all requests (should take ~10 seconds total)
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get(15, TimeUnit.SECONDS);

        // Verify all requests succeeded despite being slow
        long successfulPayments = futures.stream()
            .mapToLong(future -> {
                try {
                    PaymentResult result = future.get();
                    return "SUCCESS".equals(result.getStatus()) ? 1 : 0;
                } catch (Exception e) {
                    return 0;
                }
            })
            .sum();

        assertThat(successfulPayments).isEqualTo(5);
        assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
    }

    @Test
    void shouldOpenCircuitWhenSlowCallRateExceeded() throws Exception {
        // Chaos Scenario: Service becomes extremely slow (exceeding slow call threshold)
        
        when(externalPaymentService.processPayment(any()))
            .then(invocation -> {
                // Simulate very slow response (4 seconds, above 3s threshold)
                Thread.sleep(4000);
                return PaymentResult.success("Too slow", "txn-veryslow");
            });

        // Execute enough slow requests to trigger slow call rate threshold
        List<CompletableFuture<PaymentResult>> futures = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            PaymentRequest request = new PaymentRequest("veryslow-" + i, 100.0, "USD");
            futures.add(resilientQueryService.processPayment(request));
        }

        // Wait for circuit breaker to open due to slow call rate
        await().atMost(30, TimeUnit.SECONDS).untilAsserted(() -> {
            assertThat(paymentCircuitBreaker.getState()).isEqualTo(CircuitBreaker.State.OPEN);
        });

        // Verify slow call rate exceeded threshold
        assertThat(paymentCircuitBreaker.getMetrics().getSlowCallRate()).isGreaterThan(50.0f);
    }

    @Test
    void shouldMaintainThroughputDuringChaos() throws Exception {
        // Chaos Scenario: Mixed workload with various failure types
        
        when(externalPaymentService.processPayment(any()))
            .thenReturn(PaymentResult.success("Success", "txn-1"))
            .thenThrow(new SocketTimeoutException("Timeout"))
            .thenReturn(PaymentResult.success("Success", "txn-2"))
            .thenReturn(PaymentResult.success("Success", "txn-3"))
            .thenThrow(new ConnectException("Connection failed"));

        when(externalInventoryService.checkStockLevel(anyString()))
            .thenReturn(new StockLevel("product-1", 10, false))
            .thenThrow(new SocketTimeoutException("Inventory timeout"))
            .thenReturn(new StockLevel("product-2", 5, false));

        // Execute mixed workload
        long startTime = System.currentTimeMillis();
        
        List<CompletableFuture<?>> allFutures = new ArrayList<>();
        
        // Payment requests
        for (int i = 0; i < 10; i++) {
            PaymentRequest request = new PaymentRequest("mixed-" + i, 100.0, "USD");
            allFutures.add(resilientQueryService.processPayment(request));
        }
        
        // Inventory requests
        for (int i = 0; i < 10; i++) {
            allFutures.add(resilientQueryService.checkStockLevel("product-" + i));
        }

        // Wait for all operations
        CompletableFuture.allOf(allFutures.toArray(new CompletableFuture[0])).get(15, TimeUnit.SECONDS);
        
        long duration = System.currentTimeMillis() - startTime;

        // Verify reasonable throughput maintained (all 20 operations in < 15 seconds)
        assertThat(duration).isLessThan(15000);
        
        // Verify at least some operations succeeded despite chaos
        long completedOperations = allFutures.stream()
            .mapToLong(future -> {
                try {
                    future.get();
                    return 1;
                } catch (Exception e) {
                    return 1; // Even fallbacks count as completed
                }
            })
            .sum();

        assertThat(completedOperations).isEqualTo(20); // All should complete (success or fallback)
    }
}