package com.ordersystem.query.security;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.ActiveProfiles;

import java.time.Duration;
import java.util.Set;

import static org.assertj.core.api.Assertions.*;

/**
 * JWT Token Service Security Tests - Enterprise-grade token management
 * TARGET: 15min access token, 7day refresh token, automatic rotation
 */
@SpringBootTest
@ActiveProfiles("test")
class JwtTokenServiceTest {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    private JwtTokenService jwtTokenService;

    @BeforeEach
    void setUp() {
        jwtTokenService = new JwtTokenService();
        jwtTokenService.setRedisTemplate(redisTemplate);
        // Clear Redis for clean test state
        redisTemplate.getConnectionFactory().getConnection().flushAll();
    }

    @Test
    void shouldGenerateTokenPairWithCorrectExpiration() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair tokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        assertThat(tokenPair).isNotNull();
        assertThat(tokenPair.getAccessToken()).isNotEmpty();
        assertThat(tokenPair.getRefreshToken()).isNotEmpty();
        
        // Verify token expiration times
        assertThat(jwtTokenService.getExpirationTime(tokenPair.getAccessToken()))
                .isCloseTo(System.currentTimeMillis() + (15 * 60 * 1000), within(5000L));
    }

    @Test
    void shouldStoreRefreshTokenHashInRedis() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair tokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        // Verify refresh token hash is stored in Redis
        String storedHash = redisTemplate.opsForValue().get("refresh_token:" + userId);
        assertThat(storedHash).isNotNull();
        assertThat(storedHash).isNotEqualTo(tokenPair.getRefreshToken()); // Should be hashed
    }

    @Test
    void shouldValidateAccessTokenCorrectly() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair tokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        boolean isValid = jwtTokenService.validateAccessToken(tokenPair.getAccessToken());
        assertThat(isValid).isTrue();
        
        // Test with invalid token
        boolean isInvalid = jwtTokenService.validateAccessToken("invalid.token.here");
        assertThat(isInvalid).isFalse();
    }

    @Test
    void shouldExtractUserRolesFromAccessToken() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER", "PREMIUM");
        
        TokenPair tokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        String extractedUserId = jwtTokenService.getUserIdFromToken(tokenPair.getAccessToken());
        Set<String> extractedRoles = jwtTokenService.getRolesFromToken(tokenPair.getAccessToken());
        
        assertThat(extractedUserId).isEqualTo(userId);
        assertThat(extractedRoles).containsExactlyInAnyOrderElementsOf(roles);
    }

    @Test
    void shouldRefreshTokensAndInvalidateOld() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair originalTokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        // Refresh tokens
        TokenPair newTokenPair = jwtTokenService.refreshTokens(originalTokenPair.getRefreshToken());
        
        assertThat(newTokenPair).isNotNull();
        assertThat(newTokenPair.getAccessToken()).isNotEqualTo(originalTokenPair.getAccessToken());
        assertThat(newTokenPair.getRefreshToken()).isNotEqualTo(originalTokenPair.getRefreshToken());
        
        // Old refresh token should be invalidated
        assertThatThrownBy(() -> jwtTokenService.refreshTokens(originalTokenPair.getRefreshToken()))
                .isInstanceOf(InvalidTokenException.class)
                .hasMessage("Invalid refresh token");
    }

    @Test
    void shouldRejectExpiredAccessTokens() throws InterruptedException {
        // Create token service with very short expiration for testing
        JwtTokenService shortLivedTokenService = new JwtTokenService();
        shortLivedTokenService.setAccessTokenValidityMs(100); // 100ms
        
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair tokenPair = shortLivedTokenService.generateTokenPair(userId, roles);
        
        // Wait for token to expire
        Thread.sleep(150);
        
        boolean isValid = shortLivedTokenService.validateAccessToken(tokenPair.getAccessToken());
        assertThat(isValid).isFalse();
    }

    @Test
    void shouldHandleTokenRotationRaceCondition() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        TokenPair tokenPair = jwtTokenService.generateTokenPair(userId, roles);
        
        // Simulate concurrent refresh attempts
        TokenPair newTokenPair1 = jwtTokenService.refreshTokens(tokenPair.getRefreshToken());
        
        // Second attempt should fail with the original refresh token
        assertThatThrownBy(() -> jwtTokenService.refreshTokens(tokenPair.getRefreshToken()))
                .isInstanceOf(InvalidTokenException.class);
        
        // But new refresh token should work
        TokenPair newTokenPair2 = jwtTokenService.refreshTokens(newTokenPair1.getRefreshToken());
        assertThat(newTokenPair2).isNotNull();
    }

    @Test
    void shouldSetCorrectRedisExpirationForRefreshTokens() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        jwtTokenService.generateTokenPair(userId, roles);
        
        Duration ttl = redisTemplate.getExpire("refresh_token:" + userId);
        assertThat(ttl.toSeconds()).isCloseTo(7 * 24 * 60 * 60, within(10L)); // 7 days Â± 10 seconds
    }

    @Test
    void shouldGenerateSecureRandomTokens() {
        String userId = "user123";
        Set<String> roles = Set.of("CUSTOMER");
        
        // Generate multiple token pairs to check randomness
        TokenPair tokenPair1 = jwtTokenService.generateTokenPair(userId, roles);
        TokenPair tokenPair2 = jwtTokenService.generateTokenPair(userId, roles);
        
        assertThat(tokenPair1.getAccessToken()).isNotEqualTo(tokenPair2.getAccessToken());
        assertThat(tokenPair1.getRefreshToken()).isNotEqualTo(tokenPair2.getRefreshToken());
    }
}